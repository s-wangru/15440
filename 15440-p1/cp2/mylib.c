
/*
	This is a client stub library that helps with interposing the remote procedure 
	calls in place of the local service routines. The function marshalls the parameters
	to a function into request packets then send to the server and clients will receive 
	the response packet then demarshall it into output parameters and return to user
*/


#define _GNU_SOURCE

#include <dlfcn.h>
#include <stdio.h>
 
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdarg.h>

#include <stdlib.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <string.h>
#include <err.h>
#include <errno.h>
#include "../include/dirtree.h"

#define MAXMSGLEN 200
#define fdOffset 20000

int sockfd = 0;


// The following line declares function pointers with the same prototype as the original function calls

int (*orig_open)(const char *pathname, int flags, ...);  // mode_t mode is needed when flags includes O_CREAT

int (*orig_close)(int fd);

ssize_t (*orig_read)(int fildes, void *buf, size_t nbyte);

ssize_t (*orig_write)(int fildes, const void *buf, size_t nbyte);

off_t (*orig_lseek)(int fd, off_t offset, int whence);

int (*orig_stat)(const char *restrict path, struct stat *restrict buf);

int (*orig_unlink)(const char *path);

ssize_t (*orig_getdirentries)(int fd, char *buf, size_t nbytes , off_t *basep);

struct dirtreenode* (*orig_getdirtree)( const char *path );

void (*orig_freedirtree)( struct dirtreenode* dt );

/// @brief send the message arg of length arglen to the server and receive the result of execution
/// @param arg message to be sent to the server
/// @param arglen length of the message
/// @return the response from the server after execution
char* sendToServer(char* arg, int arglen){

	char* msg = arg;

	send(sockfd, msg, arglen, 0); //send request pakcet to server
	char size[4];
	int rv;

	while((rv =recv(sockfd, size, sizeof(int), 0)) >0){ // this receives the size of the entire buffer
		if (*(int*)size > 0){
			break;
		}
	}
	if (rv<0){
		err(1,0);			// in case something went wrong
	}

	int bufSize; //size of the response buffer
	memcpy(&bufSize,size,sizeof(int));
	char *buf = malloc(bufSize);
	if (buf == NULL){
		err(1,0);
	}
    int maxSize = MAXMSGLEN;
    int currlen = 0;
    if (bufSize - currlen < MAXMSGLEN){
        maxSize = bufSize;
    }
    while (currlen < bufSize){
		rv = recv(sockfd,buf+currlen,maxSize,0);
		if (rv<0){
			free(buf);
			err(1,0);			// in case something went wrong
		}
        currlen += rv;
        if (bufSize - currlen < maxSize){
            maxSize = bufSize-currlen;
        }
    }

	return buf;
}


/// @brief interposed open function that marshall and unmarshall the 
/// 	   request and reply packet respectively
/// @param pathname path to the file to be opened
/// @param flags flags for the opening file
/// @param  modes
/// @return file descriptor
int open(const char *pathname, int flags, ...) {
	mode_t m=0;
	if (flags & O_CREAT) {
		va_list a;
		va_start(a, flags);
		m = va_arg(a, mode_t);
		va_end(a);
	}
    size_t pathLen = strlen(pathname);

    size_t len = sizeof(int)*2 + pathLen + sizeof(int) + sizeof(size_t) + sizeof(mode_t);
    char buf[len+1];
    int fID = 0;
    int cnt = 0;
    memcpy(buf,&fID,sizeof(int));
    cnt += sizeof(int);
	int bufLen = len-sizeof(int)*2;
	memcpy(buf+cnt,&bufLen,sizeof(int));
	cnt += sizeof(int);

    memcpy(buf+cnt,&flags,sizeof(int));
    cnt += sizeof(int);
    memcpy(buf+cnt, &m, sizeof(mode_t));
    cnt += sizeof(int);
    memcpy(buf+cnt, &pathLen, sizeof(size_t));
    cnt += sizeof(size_t);
    memcpy(buf+cnt,pathname,pathLen);
	
	char* retval = sendToServer(buf,len);
    int res = *(int*)retval;
    int err = *(int*)(retval+sizeof(int));
    if (res < 0){	//check if an error happened during execution
        errno = err;
		free(retval);
		return res;
    }
	free(retval);
	return res+fdOffset;	//add the fdOffset to indicate the fd is generated by server
}


/// @brief interposed close function that marshall and unmarshall the 
/// 	   request and reply packet respectively
/// @param fd file descriptor to be closed
/// @return 0 if succesfully executed, -1 if an error happens
int close(int fd){
	//check if fd is created locally or on the server
	if (fd <= fdOffset){
		return orig_close(fd);
	}else{
		fd -= fdOffset;
	}
	size_t len = sizeof(int)*3;
    char buf[len+1];
    int fID = 1;
    memcpy(buf, &fID, sizeof(int));
	int bufLen = len-sizeof(int)*2;
	int cnt = sizeof(int);
	memcpy(buf+cnt,&bufLen,sizeof(int));
	cnt += sizeof(int);
    memcpy(buf+cnt,&fd,4);
    char* retval = sendToServer(buf,len);
	fprintf(stderr,"close called on fd: %d\n",fd);
    int res = *(int*)retval;
    int err = *(int*)(retval+sizeof(int));
    if (res < 0){
        errno = err;
    }
	free(retval);
	return res;
}

/// @brief interposed read function that marshall and unmarshall the 
/// 	   request and reply packet respectively
/// @param fildes file descriptor to read from
/// @param buf destination of the read buffer
/// @param nbyte how many bytes to read
/// @return number of bytes read from the location
ssize_t read(int fildes, void *buf, size_t nbyte){
	if (fildes <= fdOffset){
		return orig_read(fildes,buf,nbyte);
	}else{
		fildes -= fdOffset;
	}
	size_t len = sizeof(int)*3 + sizeof(size_t);
	char buff[len+1];
	int fID = 3;
	int cnt = 0;
	memcpy(buff, &fID, sizeof(int));
	cnt += sizeof(int);
	int bufLen = len-sizeof(int)*2;
	memcpy(buff+cnt,&bufLen,sizeof(int));
	cnt += sizeof(int);
	memcpy(buff+cnt, &fildes, sizeof(int));
	cnt += sizeof(int);
	memcpy(buff+cnt,&nbyte,sizeof(size_t));
	char* retval = sendToServer(buff,len);
	ssize_t res = *(ssize_t*)retval;
	int err = *(int*)(retval+sizeof(ssize_t));
	if (res < 0){
		errno = err;
	}else{
		memcpy(buf, retval + sizeof(int)+sizeof(ssize_t), res);
	}
	free(retval);
	return res;
}

/// @brief interposed write function that marshall and unmarshall the 
/// 	   request and reply packet respectively
/// @param fildes file descriptor to write to
/// @param buf the source buffer to write to the file
/// @param nbyte how many bytes to write
/// @return number of bytes wrote into the file
ssize_t write(int fildes, const void *buf, size_t nbyte){
	if (fildes <= fdOffset){
		return orig_write(fildes,buf,nbyte);
	}else{
		fildes -= fdOffset;
	}
    size_t len = sizeof(int)*3 + sizeof(size_t) +nbyte;
    char buff[len+1];
    int fID = 2;
    int cnt = 0;
    memcpy(buff,&fID,sizeof(int));
    cnt += sizeof(int);
	int bufLen = len-sizeof(int)*2;
	memcpy(buff+cnt,&bufLen,sizeof(int));
	cnt += sizeof(int);
    memcpy(buff+cnt, &fildes, sizeof(int));
    cnt += sizeof(int);
    memcpy(buff+cnt, &nbyte, sizeof(size_t));
    cnt += sizeof(size_t);
    memcpy(buff+cnt,buf,nbyte);
	char* retval = sendToServer(buff,len);
    ssize_t res = *(ssize_t*)retval;
    int err = *(int*)(retval+sizeof(ssize_t));
    if (res == -1){
        errno = err;
    }
	free(retval);
	return res;
}

/// @brief interposed lseek function that marshall and unmarshall the 
/// 	   request and reply packet respectively
/// @param fd file descriptor to be modified
/// @param offset offset to be adjusted
/// @param whence where the offset starts
/// @return resulting offset, as measured in bytes from the beginning of the file,
off_t lseek(int fd, off_t offset, int whence){
	if (fd <= fdOffset){
		return orig_lseek(fd,offset,whence);
	}else{
		fd -= fdOffset;
	}
	size_t len = sizeof(int)*4 + sizeof(off_t);
	char buff[len+1];
	int fID = 4;
	int cnt = 0;
	memcpy(buff, &fID, sizeof(int));
	cnt += sizeof(int);
	int bufLen = len-sizeof(int)*2;
	memcpy(buff+cnt,&bufLen,sizeof(int));
	cnt += sizeof(int);
	memcpy(buff+cnt, &fd, sizeof(int));
	cnt += sizeof(int);
	memcpy(buff+cnt, &offset, sizeof(off_t));
	cnt += sizeof(off_t);
	memcpy(buff+cnt,&whence, sizeof(int));
	char *retval = sendToServer(buff,len);
	off_t res = *(off_t*)retval;
	int err = *(int*)(retval+sizeof(off_t));
    if (res < 0){
        errno = err;
    }
	free(retval);
	return res;
}


/// @brief  interposed stat function that marshall and unmarshall the 
/// 	   request and reply packet respectively
/// @param path the path to the target file
/// @param buf destination buffer for the data
/// @return 0 if succesfully executed, -1 if an error happens
int stat(const char *restrict path, struct stat *restrict buf){
	int n = (int) strlen(path);
	size_t len = sizeof(int)*3+ n + sizeof(struct stat);
	char buff[len];
	int fID = 5;
	int cnt = 0;
	memcpy(buff,&fID,sizeof(int));
	cnt += sizeof(int);
	int bufLen = len-sizeof(int)*2;
	memcpy(buff+cnt,&bufLen,sizeof(int));
	cnt += sizeof(int);
	memcpy(buff+cnt,&n,sizeof(int));
	cnt += sizeof(int);
	memcpy(buff+cnt, path, n);
	char *retval = sendToServer(buff,len);
	int res = *(int*)retval;
	int err = *(int*)(retval+sizeof(int));
	memcpy(buf, retval + sizeof(int)*2, sizeof(struct stat));
	if (res < 0){
		errno = err;
	}
	free(retval);
	return res;
}


/// @brief interposed unlink function that marshall and unmarshall the 
/// 	   request and reply packet respectively
/// @param path the path of the file to be unlinked
/// @return 0 if succesfully executed, -1 if an error happens
int unlink(const char *path){
	size_t len = sizeof(int)*3 + strlen(path);
	char buf[len];
	int fID = 6;
	int cnt = 0;
	int n = (int)strlen(path);
	memcpy(buf, &fID, sizeof(int));
	cnt += sizeof(int);
	int bufLen = len-sizeof(int)*2;
	memcpy(buf+cnt,&bufLen,sizeof(int));
	cnt += sizeof(int);
	memcpy(buf+cnt, &n, sizeof(int));
	cnt += sizeof(int);
	memcpy(buf+cnt,path, n);
	char *retval = sendToServer(buf,len);
	int res = *(int*)retval;
	int err = *(int*)(retval+sizeof(int));
	if (res == -1){
		errno = err;
	}
	free(retval);
	return res;
}

/// @brief interposed getdirentries function that marshall and unmarshall the 
/// 	   request and reply packet respectively
/// @param fd directory specified by fd
/// @param buf destination buffer to read the directory entries into
/// @param nbytes number of bytes to read
/// @param basep the offset to start at
/// @return number of bytes read
ssize_t getdirentries(int fd, char *buf, size_t nbytes , off_t *basep){
	if (fd <= fdOffset){
		return orig_getdirentries(fd,buf,nbytes,basep);
	}else{
		fd -= fdOffset;
	}
	size_t len = sizeof(int)*3 + sizeof(size_t) + sizeof(off_t);
	char buff[len];
	int fID = 7;
	int cnt = 0;
	memcpy(buff, &fID, sizeof(int));
	cnt += sizeof(int);
	int bufLen = len-sizeof(int)*2;
	memcpy(buff+cnt,&bufLen,sizeof(int));
	cnt += sizeof(int);
	memcpy(buff+cnt, &fd, sizeof(int));
	cnt += sizeof(int);
	memcpy(buff + cnt, &nbytes, sizeof(size_t));
	cnt += sizeof(size_t);
	memcpy(buff+cnt, basep, sizeof(off_t));
	char *retval = sendToServer(buff,len);
	ssize_t res = *(ssize_t*)retval;
	int err = *(int*)(retval+sizeof(ssize_t));
	if (res == -1){
		errno = err;
	}else{
		memcpy(buf,retval+sizeof(int)+sizeof(ssize_t),res);
	}
	free(retval);
	return res;
}

/// @brief a helper struct to store the tree node and 
/// 	   how much bytes in the buffer have been read
struct treeRecur{
	struct dirtreenode* tree;
	int offset;
};

/// @brief a recursive approach to deserialize the buffer into a tree 
///		   by reversing the preorder traversal
struct treeRecur deserial(char* buf){
	if (*buf == '\0'){
		struct treeRecur base;
		base.tree = NULL;
		base.offset = 0;
		return base;
	}
	int nameSize = *(int*)buf;
	int numSub = *(int*)(buf+sizeof(int));
	char *name = malloc(nameSize+1);
	if (name == NULL){
        err(1,0);
    }
	memcpy(name, buf+sizeof(int)*2, nameSize);
	name[nameSize] ='\0';
	struct dirtreenode* t = calloc(sizeof(struct dirtreenode),1);
	t->name = name;
	t->num_subdirs = numSub;
	int offset = sizeof(int)*2 + nameSize;
	t->subdirs = calloc(sizeof(struct dirtreenode*),numSub);
	for (int i = 0; i < numSub; i++){
		struct treeRecur newT = deserial(buf+offset);
		offset += newT.offset;
		t->subdirs[i] = newT.tree;
	}
	struct treeRecur ret;
	ret.tree = t;
	ret.offset = offset;
	return ret;
}

/// @brief interposed getdirtree function that marshall and unmarshall the 
/// 	   request and reply packet respectively
struct dirtreenode* getdirtree( const char *path ){
	int pathLen = (int) strlen(path);
    size_t len = sizeof(int)*3 + pathLen;
    char buf[len];
    int fID = 8;
    int cnt = 0;
    memcpy(buf, &fID, sizeof(int));
    cnt += sizeof(int);
    int bufLen = len-sizeof(int)*2;
    memcpy(buf+cnt,&bufLen,sizeof(int));
    cnt += sizeof(int);
    memcpy(buf+cnt, &pathLen, sizeof(int));
    cnt += sizeof(int);
    memcpy(buf+cnt, path, pathLen);
    char *retval = sendToServer(buf,len); 
	int error = *(int*)retval;
	if (error == 1){
		int err = *(int*)(retval + sizeof(int));
		errno = err;
		free(retval);
		return NULL;
	}else{
		struct treeRecur t = deserial(retval+sizeof(int)*2+sizeof(ssize_t));
		free(retval);
		return t.tree;
	}
}

/// @brief recursive helper function that frees each node's name and 
/// 		list of subdirectories, then the node it self
/// @param dt the root of the tree to be freed
void freeHelper(struct dirtreenode* dt){
	if (dt == NULL) return;
	free(dt->name);
	for(int i = 0; i < dt->num_subdirs; i++){
		freeHelper(dt->subdirs[i]);
	}
	free(dt->subdirs);
	free(dt); 
}

/// @brief interposed freedirtree function that marshall and unmarshall the 
/// 	   request and reply packet respectively
/// @param dt the tree to be freed
void freedirtree( struct dirtreenode* dt ){
	return freeHelper(dt);
}

/// @brief each client only has one session with the server which is connected when the program is started
void _init(void) {
	// set function pointer orig_... to point to the original open function
	orig_open = dlsym(RTLD_NEXT, "open");
	orig_close = dlsym(RTLD_NEXT, "close");
	orig_read = dlsym(RTLD_NEXT, "read");
	orig_write = dlsym(RTLD_NEXT, "write");
	orig_lseek = dlsym(RTLD_NEXT, "lseek");
	orig_stat = dlsym(RTLD_NEXT, "stat");
	orig_unlink = dlsym(RTLD_NEXT, "unlink");
	orig_getdirentries = dlsym(RTLD_NEXT, "getdirentries");
	orig_getdirtree = dlsym(RTLD_NEXT, "getdirtree");
	char *serverip;
	char *serverport;
	unsigned short port;
	int rv;
	struct sockaddr_in srv;
	serverip = getenv("server15440");

	if (serverip) {
	}
	else {
		serverip = "127.0.0.1";
	}

	serverport = getenv("serverport15440");
	if (serverport) {
	}
	else {
		serverport = "15400";
	}
	port = (unsigned short)atoi(serverport);

	// Create socket
	sockfd = socket(AF_INET, SOCK_STREAM, 0);	// TCP/IP socket
	if (sockfd<0) err(1, 0);			// in case of error
	
	// setup address structure to point to server
	memset(&srv, 0, sizeof(srv));				// clear it first
	srv.sin_family = AF_INET;					// IP family
	srv.sin_addr.s_addr = inet_addr(serverip);	// IP address of server
	srv.sin_port = htons(port);					// server port


	rv = connect(sockfd, (struct sockaddr*)&srv, sizeof(struct sockaddr));
	if (rv<0) err(1,0);
}

/// @brief the connection to the server is closed when the execution finishes
void _fini(void){
	int rv = orig_close(sockfd);
	if (rv < 0){
		err(1,0);
	}
}


